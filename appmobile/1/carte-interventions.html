<!DOCTYPE html>
<html class="light" lang="fr"><head>
<meta charset="utf-8"/>
<meta content="width=device-width, initial-scale=1.0" name="viewport"/>
<meta name="theme-color" content="#F59E0B"/>
<link rel="manifest" href="./manifest.json"/>
<title>Carte des Interventions</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet" media="print" onload="this.media='all'"/>
<link href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:wght,FILL@100..700,0..1&display=swap" rel="stylesheet" media="print" onload="this.media='all'"/>
<script src="https://cdn.tailwindcss.com?plugins=forms,container-queries"></script>
<script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2.39.8/dist/umd/supabase.min.js" defer></script>
<script src="../../js/config.js?v=7" defer></script>
<script src="../../js/api.js?v=7" defer></script>
<script>
    // Chargement robuste de CSS Leaflet
    function loadLeafletCSS(href) {
        return new Promise((resolve, reject) => {
            const link = document.createElement('link');
            link.rel = 'stylesheet';
            link.href = href;
            link.onload = () => {
                console.log('✅ CSS Leaflet chargé depuis:', href);
                resolve();
            };
            link.onerror = () => {
                console.error('❌ Échec CSS Leaflet depuis:', href);
                reject();
            };
            document.head.appendChild(link);
        });
    }

    (async () => {
        try {
            await loadLeafletCSS('https://unpkg.com/leaflet@1.9.4/dist/leaflet.min.css');
        } catch (e) {
            console.log('Tentative CSS alternatif...');
            try {
                await loadLeafletCSS('https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.css');
            } catch (e2) {
                console.error('Impossible de charger CSS Leaflet');
            }
        }
    })();
</script>
<script>
        // Chargement robuste de Leaflet avec fallback
        window.leafletLoaded = false;
        window.leafletError = null;
        
        function loadLeaflet(src) {
            return new Promise((resolve, reject) => {
                const script = document.createElement('script');
                script.src = src;
                script.onload = () => {
                    console.log('✅ Leaflet chargé depuis:', src);
                    window.leafletLoaded = true;
                    resolve();
                };
                script.onerror = () => {
                    console.error('❌ Échec chargement Leaflet depuis:', src);
                    reject(new Error('Échec chargement depuis ' + src));
                };
                document.head.appendChild(script);
            });
        }
        
        // Essayer de charger Leaflet depuis unpkg, sinon cdnjs
        (async () => {
            try {
                await loadLeaflet('https://unpkg.com/leaflet@1.9.4/dist/leaflet.min.js');
            } catch (e) {
                console.log('Tentative CDN alternatif...');
                try {
                    await loadLeaflet('https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.9.4/leaflet.min.js');
                } catch (e2) {
                    window.leafletError = 'Impossible de charger Leaflet depuis les CDN';
                    console.error(window.leafletError);
                }
            }
        })();
    </script>
<script>
        tailwind.config = {
            darkMode: "class",
            theme: {
                extend: {
                    colors: {
                        "primary": "#135bec",
                        "background-light": "#f6f6f8",
                        "background-dark": "#101622",
                        "surface-light": "#ffffff",
                        "surface-dark": "#1c2433",
                        "text-main-light": "#111318",
                        "text-main-dark": "#e2e8f0",
                        "text-sub-light": "#616f89",
                        "text-sub-dark": "#94a3b8",
                        "border-light": "#e2e8f0",
                        "border-dark": "#2d3748"
                    },
                    fontFamily: {
                        "display": ["Inter", "sans-serif"]
                    },
                    borderRadius: { "DEFAULT": "0.375rem", "lg": "0.5rem", "xl": "0.75rem", "2xl": "1rem", "full": "9999px" },
                },
            },
        }
    </script>
<style>
    body {
      min-height: max(884px, 100dvh);
    }
    #map {
        width: 100%;
        height: 100%;
        z-index: 1;
        position: relative;
        background-color: #f3f4f6;
    }
    .leaflet-container {
        width: 100%;
        height: 100%;
        font-family: inherit;
    }
    .leaflet-popup-content-wrapper {
        border-radius: 12px;
    }
  </style>
  </head>
<body class="font-display bg-background-light dark:bg-background-dark text-text-main-light dark:text-text-main-dark antialiased selection:bg-primary selection:text-white" style="margin: 0; padding: 0; overflow: hidden;">
<div class="relative flex flex-col h-screen w-full max-w-md mx-auto bg-background-light dark:bg-background-dark shadow-xl" style="height: 100vh; overflow: hidden;">
<!-- Header -->
<header class="sticky top-0 z-20 bg-surface-light/95 dark:bg-surface-dark/95 backdrop-blur-md border-b border-border-light dark:border-border-dark px-4 pt-12 pb-4 shadow-sm">
<div class="flex items-center justify-between mb-4">
<button onclick="goBack()" class="p-2 rounded-full hover:bg-background-light dark:hover:bg-background-dark text-text-main-light dark:text-text-main-dark transition-colors" title="Retour">
<span class="material-symbols-outlined">arrow_back</span>
</button>
<h1 class="text-lg font-bold tracking-tight">Carte des Interventions</h1>
<div class="w-10"></div>
</div>
<!-- Date Selector -->
<div class="flex items-center justify-between bg-background-light dark:bg-background-dark rounded-xl p-3">
<button onclick="changeDate(-1)" class="p-2 rounded-full hover:bg-surface-light dark:hover:bg-surface-dark text-text-main-light dark:text-text-main-dark transition-colors" title="Jour précédent">
<span class="material-symbols-outlined">chevron_left</span>
</button>
<div class="flex flex-col items-center flex-1">
<span id="date-label" class="text-xs font-semibold text-primary uppercase tracking-wider">Aujourd'hui</span>
<span id="date-display" class="text-sm font-bold text-text-main-light dark:text-text-main-dark">Chargement...</span>
</div>
<button onclick="changeDate(1)" class="p-2 rounded-full hover:bg-surface-light dark:hover:bg-surface-dark text-text-main-light dark:text-text-main-dark transition-colors" title="Jour suivant">
<span class="material-symbols-outlined">chevron_right</span>
</button>
</div>
</header>
<!-- Map Container -->
<div class="relative w-full" style="min-height: 500px; height: calc(100vh - 200px); flex: 1;">
    <div id="map" class="w-full h-full bg-gray-100"></div>
    <div id="map-loading" class="absolute inset-0 flex items-center justify-center bg-gray-100 text-gray-500 z-10">
        <div class="text-center">
            <span class="material-symbols-outlined text-4xl mb-2 animate-pulse">map</span>
            <p class="text-sm">Chargement de la carte...</p>
        </div>
    </div>
</div>
<!-- Bottom Navigation -->
<nav class="fixed bottom-0 w-full max-w-md bg-surface-light dark:bg-surface-dark border-t border-border-light dark:border-border-dark pb-safe pt-2 px-2 z-30 pb-4">
<div class="grid grid-cols-4 gap-1">
<button class="flex flex-col items-center justify-center p-2 rounded-xl text-primary bg-primary/10">
<span class="material-symbols-outlined filled">map</span>
<span class="text-[10px] font-medium mt-1">Carte</span>
</button>
<a href="chefintervention.html" class="flex flex-col items-center justify-center p-2 rounded-xl text-text-sub-light dark:text-text-sub-dark hover:bg-background-light dark:hover:bg-background-dark/50 transition-colors">
<span class="material-symbols-outlined">engineering</span>
<span class="text-[10px] font-medium mt-1">Interventions</span>
</a>
<a href="verification-inventaire.html" class="flex flex-col items-center justify-center p-2 rounded-xl text-text-sub-light dark:text-text-sub-dark hover:bg-background-light dark:hover:bg-background-dark/50 transition-colors">
<span class="material-symbols-outlined">inventory_2</span>
<span class="text-[10px] font-medium mt-1">Stock</span>
</a>
<a href="on-hold.html" class="flex flex-col items-center justify-center p-2 rounded-xl text-text-sub-light dark:text-text-sub-dark hover:bg-background-light dark:hover:bg-background-dark/50 transition-colors">
<span class="material-symbols-outlined">report_problem</span>
<span class="text-[10px] font-medium mt-1">On Hold</span>
</a>
</div>
</nav>
</div>

<script>
// ===== STATE =====
let map = null;
let markers = [];
let currentDate = new Date();
let currentUserRole = null;

// ===== CACHE SYSTEM =====
const CACHE_PREFIX = 'chef_chantier_';
const CACHE_DURATION = 30 * 24 * 60 * 60 * 1000; // 30 jours (1 mois)

// Sauvegarder dans le cache
function saveToCache(key, data) {
    try {
        const cacheData = {
            data: data,
            timestamp: Date.now()
        };
        localStorage.setItem(CACHE_PREFIX + key, JSON.stringify(cacheData));
        console.log('Données sauvegardées dans le cache:', key);
    } catch (error) {
        console.error('Erreur sauvegarde cache:', error);
    }
}

// Charger depuis le cache
function loadFromCache(key) {
    try {
        const cached = localStorage.getItem(CACHE_PREFIX + key);
        if (!cached) return null;
        
        const cacheData = JSON.parse(cached);
        const age = Date.now() - cacheData.timestamp;
        
        // Vérifier si le cache est encore valide (moins de 1 mois)
        if (age < CACHE_DURATION) {
            console.log('Données chargées depuis le cache:', key, '(âge:', Math.round(age/(24*60*60*1000)), 'jours)');
            return cacheData.data;
        } else {
            // Cache expiré, le supprimer
            localStorage.removeItem(CACHE_PREFIX + key);
            console.log('Cache expiré pour:', key);
            return null;
        }
    } catch (error) {
        console.error('Erreur chargement cache:', error);
        return null;
    }
}

// Obtenir la clé de cache pour une date
function getCacheKey(date) {
    const dateStr = date.toISOString().split('T')[0];
    return `carte_interventions_${dateStr}`;
}

// ===== INITIALIZE =====
document.addEventListener('DOMContentLoaded', async function() {
    console.log('DOM chargé, initialisation...');
    
    // Initialiser l'app d'abord
    await initializeApp();
    updateDateDisplay();
    
    // Attendre que Leaflet soit chargé (avec timeout plus long)
    console.log('Attente du chargement de Leaflet...');
    let attempts = 0;
    while (!window.leafletLoaded && typeof L === 'undefined' && !window.leafletError && attempts < 100) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    
    if (window.leafletError || typeof L === 'undefined') {
        console.error('Leaflet non disponible:', window.leafletError || 'Timeout après 10 secondes');
        const loadingMsg = document.getElementById('map-loading');
        if (loadingMsg) {
            loadingMsg.innerHTML = `<div class="text-center text-red-500 p-4">
                <span class="material-symbols-outlined text-4xl mb-2">error</span>
                <p class="text-sm font-semibold mb-2">Erreur de chargement de la carte</p>
                <p class="text-xs mb-3">${window.leafletError || 'Bibliothèque cartographique non disponible'}</p>
                <button onclick="location.reload()" class="px-4 py-2 bg-primary text-white rounded-lg text-sm">
                    Réessayer
                </button>
            </div>`;
        }
        return;
    }
    
    console.log('✅ Leaflet disponible (L object exists)');
    
    // Initialiser la carte
    initMap();
    
    // Attendre que la carte soit prête avant de charger les données
    if (map) {
        map.whenReady(async () => {
            console.log('Carte prête, chargement des interventions...');
            // Charger d'abord depuis le cache (instantané)
            loadInterventionsFromCache();
            // Puis charger depuis Supabase et mettre à jour
            await loadInterventions();
        });
    } else {
        // Fallback si la carte n'est pas initialisée
        console.warn('Variable map non définie, tentative de chargement différé');
        setTimeout(async () => {
            loadInterventionsFromCache();
            await loadInterventions();
        }, 1000);
    }
});

async function initializeApp() {
    // Attendre que Supabase soit initialisé
    let attempts = 0;
    while ((!window.supabase || typeof window.supabase.auth === 'undefined' || typeof window.supabase.from === 'undefined') && attempts < 50) {
        await new Promise(resolve => setTimeout(resolve, 100));
        attempts++;
    }
    
    if (!window.supabase || typeof window.supabase.auth === 'undefined' || typeof window.supabase.from === 'undefined') {
        console.error('Supabase non initialisé');
        alert('Erreur de connexion. Veuillez recharger la page.');
        return;
    }
    
    // Vérifier l'authentification
    const { data: { user }, error: authError } = await window.supabase.auth.getUser();
    
    if (authError || !user) {
        window.location.href = 'index.html';
        return;
    }
    
    // Récupérer le rôle
    const { data: roleData, error: roleError } = await window.supabase
        .from('user_roles')
        .select('role')
        .eq('user_id', user.id)
        .single();
    
    if (roleError || !roleData) {
        window.location.href = 'index.html';
        return;
    }
    
    currentUserRole = roleData.role;
    
    // La carte est déjà initialisée dans DOMContentLoaded
}

function initMap() {
    const mapContainer = document.getElementById('map');
    if (!mapContainer) {
        console.error('Conteneur #map non trouvé');
        return;
    }
    
    console.log('Initialisation de Leaflet sur #map...');
    
    try {
        // Initialiser la carte
        map = L.map('map', {
            center: [46.8182, 8.2275],
            zoom: 8,
            zoomControl: true
        });
        
        console.log('Instance L.map créée');
        
        // Ajouter les tuiles OpenStreetMap
        L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
            attribution: '© OpenStreetMap contributors',
            maxZoom: 19
        }).addTo(map);
        
        console.log('Tuiles OpenStreetMap ajoutées');
        
        // Masquer le message de chargement quand les tuiles sont prêtes
        map.whenReady(() => {
            console.log('Carte Leaflet prête et rendue');
            const loadingMsg = document.getElementById('map-loading');
            if (loadingMsg) {
                loadingMsg.style.display = 'none';
            }
            
            // Forcer le redimensionnement
            setTimeout(() => {
                if (map) {
                    map.invalidateSize();
                    console.log('Carte redimensionnée (invalidateSize)');
                }
            }, 100);
        });
        
    } catch (error) {
        console.error('Erreur initialisation Leaflet:', error);
        const loadingMsg = document.getElementById('map-loading');
        if (loadingMsg) {
            loadingMsg.innerHTML = `<div class="flex flex-col items-center justify-center h-full text-red-500 p-4">
                <span class="material-symbols-outlined text-4xl mb-2">error</span>
                <p class="text-sm">Erreur: ${error.message}</p>
                <button onclick="location.reload()" class="mt-2 px-4 py-2 bg-primary text-white rounded">Recharger</button>
            </div>`;
        }
    }
}

// ===== DATE MANAGEMENT =====
function updateDateDisplay() {
    const today = new Date();
    today.setHours(0, 0, 0, 0);
    const selectedDate = new Date(currentDate);
    selectedDate.setHours(0, 0, 0, 0);
    
    const dateLabel = document.getElementById('date-label');
    const dateDisplay = document.getElementById('date-display');
    
    if (selectedDate.getTime() === today.getTime()) {
        dateLabel.textContent = "Aujourd'hui";
    } else if (selectedDate.getTime() === today.getTime() - 86400000) {
        dateLabel.textContent = "Hier";
    } else if (selectedDate.getTime() === today.getTime() + 86400000) {
        dateLabel.textContent = "Demain";
    } else {
        dateLabel.textContent = selectedDate.toLocaleDateString('fr-FR', { weekday: 'long' });
    }
    
    dateDisplay.textContent = currentDate.toLocaleDateString('fr-FR', { 
        day: 'numeric', 
        month: 'long', 
        year: 'numeric' 
    });
}

function changeDate(delta) {
    currentDate.setDate(currentDate.getDate() + delta);
    updateDateDisplay();
    // Charger d'abord depuis le cache (instantané)
    loadInterventionsFromCache();
    // Puis charger depuis Supabase et mettre à jour
    loadInterventions();
}

// ===== LOAD INTERVENTIONS FROM CACHE (INSTANTANÉ) =====
function loadInterventionsFromCache() {
    if (!map) return;
    
    const cacheKey = getCacheKey(currentDate);
    const cachedData = loadFromCache(cacheKey);
    
    if (cachedData && cachedData.markersData) {
        console.log('Affichage des données en cache (instantané)');
        
        // Supprimer les marqueurs existants
        if (markers.length > 0) {
            markers.forEach(marker => {
                if (map && marker) {
                    map.removeLayer(marker);
                }
            });
        }
        markers = [];
        
        // Recréer les marqueurs depuis le cache
        const bounds = [];
        cachedData.markersData.forEach(({ coords, initials, appointment, intervention, employee }) => {
            try {
                const marker = createMapMarker(coords, initials, appointment, intervention, employee);
                marker.addTo(map);
                markers.push(marker);
                bounds.push(coords);
            } catch (error) {
                console.error('Erreur création marqueur depuis cache:', error);
            }
        });
        
        // Ajuster la vue pour voir tous les marqueurs
        if (bounds.length > 0) {
            map.fitBounds(bounds, { padding: [50, 50] });
        } else {
            map.setView([46.8182, 8.2275], 8);
        }
    }
}

// ===== LOAD INTERVENTIONS FROM SUPABASE (MISE À JOUR) =====
async function loadInterventions() {
    if (!window.supabase) {
        console.log('Supabase non initialisé');
        // Si pas de Supabase, essayer le cache
        loadInterventionsFromCache();
        return;
    }
    
    if (!map) {
        console.log('Carte non initialisée, nouvelle tentative...');
        setTimeout(() => {
            loadInterventionsFromCache();
            loadInterventions();
        }, 200);
        return;
    }
    
    console.log('Chargement des interventions pour la carte...');
    
    // Supprimer les marqueurs existants (sauf si on vient du cache)
    if (markers.length > 0) {
        markers.forEach(marker => {
            if (map && marker) {
                map.removeLayer(marker);
            }
        });
    }
    markers = [];
    
    try {
        const dateStr = currentDate.toISOString().split('T')[0];
        
        // Charger les appointments pour cette date
        const { data: appointments, error: appointmentsError } = await window.supabase
            .from('appointments')
            .select('*')
            .eq('date', dateStr)
            .order('start_time', { ascending: true });
        
        if (appointmentsError) {
            console.error('Erreur chargement appointments:', appointmentsError);
            return;
        }
        
        if (!appointments || appointments.length === 0) {
            console.log('Aucun appointment pour cette date:', dateStr);
            // Afficher un message si aucun rendez-vous
            const mapContainer = document.getElementById('map');
            if (mapContainer && map) {
                map.setView([46.8182, 8.2275], 8);
            }
            return;
        }
        
        console.log('Appointments trouvés:', appointments.length);
        
        // Charger TOUTES les données en parallèle avec Promise.all
        const appointmentIds = appointments.map(a => a.id);
        const employeeIds = [...new Set(appointments.map(a => a.employee_id).filter(Boolean))];
        
        const [interventionsResult, employeesResult] = await Promise.all([
            // Charger les intervention_details associées
            window.supabase
                .from('intervention_details')
                .select('*')
                .in('appointment_id', appointmentIds),
            // Charger les employés
            window.supabase
                .from('employees')
                .select('id, first_name, last_name')
                .in('id', employeeIds)
        ]);
        
        const { data: interventions } = interventionsResult;
        const { data: employees } = employeesResult;
        
        // Créer un map des interventions
        const interventionsMap = {};
        (interventions || []).forEach(int => {
            interventionsMap[int.appointment_id] = int;
        });
        
        // Créer un map des employés
        const employeesMap = {};
        (employees || []).forEach(emp => {
            employeesMap[emp.id] = emp;
        });
        
        // Préparer toutes les données pour le géocodage par batchs (pour éviter de surcharger Nominatim)
        const geocodeData = [];
        const BATCH_SIZE = 5; // Nombre de requêtes parallèles max
        const DELAY_BETWEEN_BATCHES = 500; // Délai en ms entre les batchs
        
        for (let i = 0; i < appointments.length; i += BATCH_SIZE) {
            const batch = appointments.slice(i, i + BATCH_SIZE);
            
            const batchPromises = batch.map(async (appointment) => {
                const intervention = interventionsMap[appointment.id];
                const employee = employeesMap[appointment.employee_id];
                
                if (!employee) return null;
                
                // Extraire les initiales (même méthode que planif.html)
                const initials = `${employee.first_name?.[0] || ''}${employee.last_name?.[0] || ''}`.toUpperCase().substring(0, 2);
                
                // Construire l'adresse complète avec "Switzerland" (comme dans planif.html)
                const fullAddress = `${appointment.address || ''}, ${appointment.npa || ''} ${appointment.city || ''}, Switzerland`;
                
                if (!fullAddress.trim() || fullAddress.trim() === ', , Switzerland') {
                    return null;
                }
                
                try {
                    // Géocoder l'adresse avec retry en cas d'échec
                    const coords = await geocodeAddressWithRetry(fullAddress);
                    
                    if (coords) {
                        return {
                            coords,
                            initials,
                            appointment,
                            intervention,
                            employee
                        };
                    }
                } catch (error) {
                    console.error('Erreur géocodage pour', fullAddress, error);
                }
                
                return null;
            });
            
            // Attendre que le batch soit terminé
            const batchResults = await Promise.all(batchPromises);
            geocodeData.push(...batchResults.filter(r => r !== null));
            
            // Attendre avant le prochain batch (sauf pour le dernier)
            if (i + BATCH_SIZE < appointments.length) {
                await new Promise(resolve => setTimeout(resolve, DELAY_BETWEEN_BATCHES));
            }
        }
        
        const geocodedData = geocodeData;
        console.log('Données géocodées:', geocodedData.length, 'sur', appointments.length);
        
        // Filtrer les résultats null et créer tous les marqueurs
        const validData = geocodedData.filter(data => data !== null);
        console.log('Données valides (avec coordonnées):', validData.length);
        
        const bounds = [];
        
        // Ajouter tous les marqueurs d'un coup
        validData.forEach(({ coords, initials, appointment, intervention, employee }) => {
            try {
                const marker = createMapMarker(coords, initials, appointment, intervention, employee);
                marker.addTo(map);
                markers.push(marker);
                bounds.push(coords);
                console.log('Marqueur ajouté pour', appointment.client_name, 'à', coords);
            } catch (error) {
                console.error('Erreur création marqueur:', error);
            }
        });
        
        // Ajuster la vue pour voir tous les marqueurs
        if (bounds.length > 0) {
            console.log('Ajustement de la vue pour', bounds.length, 'marqueurs');
            map.fitBounds(bounds, { padding: [50, 50] });
        } else {
            // Si aucun marqueur, centrer sur la Suisse
            console.log('Aucun marqueur créé, centrage sur la Suisse');
            map.setView([46.8182, 8.2275], 8);
        }
        
        console.log('Total marqueurs créés:', markers.length);
        
        // Sauvegarder dans le cache
        const cacheKey = getCacheKey(currentDate);
        const cacheData = {
            markersData: validData
        };
        saveToCache(cacheKey, cacheData);
        
    } catch (error) {
        console.error('Erreur:', error);
        // En cas d'erreur, essayer d'afficher le cache
        loadInterventionsFromCache();
    }
}

// Cache pour éviter de géocoder plusieurs fois la même adresse
const geocodeCache = new Map();

// Géocodage avec retry (même méthode que planif.html mais avec retry)
async function geocodeAddressWithRetry(address, maxRetries = 3) {
    // Vérifier le cache d'abord
    if (geocodeCache.has(address)) {
        return geocodeCache.get(address);
    }
    
    const geocodeUrl = `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&countrycodes=ch&limit=1`;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
        try {
            // Ajouter un délai progressif entre les tentatives
            if (attempt > 1) {
                await new Promise(resolve => setTimeout(resolve, attempt * 500));
            }
            
            const response = await fetch(geocodeUrl);
            
            if (!response.ok) {
                if (response.status === 429) {
                    // Rate limit, attendre plus longtemps
                    console.log(`Rate limit détecté, tentative ${attempt}/${maxRetries}`);
                    if (attempt < maxRetries) {
                        await new Promise(resolve => setTimeout(resolve, 2000 * attempt));
                        continue;
                    }
                }
                console.error('Erreur réponse Nominatim:', response.status);
                return null;
            }
            
            const data = await response.json();
            
            if (data && data.length > 0) {
                const coords = [parseFloat(data[0].lat), parseFloat(data[0].lon)];
                // Mettre en cache
                geocodeCache.set(address, coords);
                console.log('Géocodage réussi pour', address, '->', coords);
                return coords;
            } else {
                console.log('Aucun résultat de géocodage pour', address);
                return null;
            }
        } catch (error) {
            console.error(`Erreur géocodage (tentative ${attempt}/${maxRetries}):`, error);
            if (attempt === maxRetries) {
                return null;
            }
        }
    }
    
    return null;
}

// Fonction de géocodage simple (pour compatibilité)
async function geocodeAddress(address) {
    return geocodeAddressWithRetry(address);
}

// Créer un marqueur personnalisé (même méthode que planif.html)
function createMapMarker(coords, initials, appointment, intervention, employee) {
    const status = intervention?.status || 'pending';
    const statusColor = status === 'validated' ? '#10b981' : status === 'rejected' ? '#ef4444' : '#3b82f6';
    
    const marker = L.marker(coords, {
        icon: L.divIcon({
            className: 'custom-marker',
            html: `<div style="width: 32px; height: 32px; border-radius: 50%; background-color: ${statusColor}; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.3); display: flex; align-items: center; justify-content: center; cursor: pointer;">
                <span style="color: white; font-size: 12px; font-weight: bold;">${initials}</span>
            </div>`,
            iconSize: [32, 32],
            iconAnchor: [16, 16]
        })
    });
    
    const technicianName = employee 
        ? `${employee.first_name || ''} ${employee.last_name || ''}`.trim() 
        : 'Technicien inconnu';
    
    const fullAddress = [appointment.address, appointment.npa, appointment.city]
        .filter(Boolean)
        .join(', ');
    
    const statusText = status === 'validated' ? 'Validé' : status === 'rejected' ? 'Refusé' : 'En cours';
    const statusClass = status === 'validated' ? 'bg-green-100 text-green-700' : status === 'rejected' ? 'bg-red-100 text-red-700' : 'bg-blue-100 text-blue-700';
    
    const popupContent = `
        <div style="padding: 8px; min-width: 200px;">
            <h3 style="font-weight: bold; font-size: 14px; margin-bottom: 4px;">${appointment.client_name || 'Client'}</h3>
            <p style="font-size: 12px; color: #666; margin-bottom: 8px;">${fullAddress}</p>
            <p style="font-size: 11px; color: #999; margin-bottom: 4px;">Technicien: ${technicianName}</p>
            <p style="font-size: 11px; color: #999; margin-bottom: 8px;">${appointment.start_time.substring(0, 5)} - ${appointment.end_time.substring(0, 5)}</p>
            ${intervention ? `<p style="font-size: 11px; margin-top: 4px;"><span style="padding: 2px 8px; border-radius: 12px; ${statusClass}">${statusText}</span></p>` : ''}
        </div>
    `;
    
    marker.bindPopup(popupContent);
    return marker;
}

function goBack() {
    window.location.href = 'chefintervention.html';
}
</script>
</body>
</html>

